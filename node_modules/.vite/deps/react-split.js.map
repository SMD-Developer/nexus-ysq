{
  "version": 3,
  "sources": ["../../react-split/dist/react-split.es.js", "../../split.js/dist/split.es.js"],
  "sourcesContent": ["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Split from 'split.js';\r\n\r\nfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\r\n\r\nvar SplitWrapper = /*@__PURE__*/(function (superclass) {\r\n    function SplitWrapper () {\r\n        superclass.apply(this, arguments);\r\n    }\r\n\r\n    if ( superclass ) SplitWrapper.__proto__ = superclass;\r\n    SplitWrapper.prototype = Object.create( superclass && superclass.prototype );\r\n    SplitWrapper.prototype.constructor = SplitWrapper;\r\n\r\n    SplitWrapper.prototype.componentDidMount = function componentDidMount () {\r\n        var ref = this.props;\r\n        ref.children;\r\n        var gutter = ref.gutter;\r\n        var rest = objectWithoutProperties( ref, [\"children\", \"gutter\"] );\r\n        var options = rest;\r\n\r\n        options.gutter = function (index, direction) {\r\n            var gutterElement;\r\n\r\n            if (gutter) {\r\n                gutterElement = gutter(index, direction);\r\n            } else {\r\n                gutterElement = document.createElement('div');\r\n                gutterElement.className = \"gutter gutter-\" + direction;\r\n            }\r\n\r\n            // eslint-disable-next-line no-underscore-dangle\r\n            gutterElement.__isSplitGutter = true;\r\n            return gutterElement\r\n        };\r\n\r\n        this.split = Split(this.parent.children, options);\r\n    };\r\n\r\n    SplitWrapper.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {\r\n        var this$1 = this;\r\n\r\n        var ref = this.props;\r\n        ref.children;\r\n        var minSize = ref.minSize;\r\n        var sizes = ref.sizes;\r\n        var collapsed = ref.collapsed;\r\n        var rest = objectWithoutProperties( ref, [\"children\", \"minSize\", \"sizes\", \"collapsed\"] );\r\n        var options = rest;\r\n        var prevMinSize = prevProps.minSize;\r\n        var prevSizes = prevProps.sizes;\r\n        var prevCollapsed = prevProps.collapsed;\r\n\r\n        var otherProps = [\r\n            'maxSize',\r\n            'expandToMin',\r\n            'gutterSize',\r\n            'gutterAlign',\r\n            'snapOffset',\r\n            'dragInterval',\r\n            'direction',\r\n            'cursor' ];\r\n\r\n        var needsRecreate = otherProps\r\n            // eslint-disable-next-line react/destructuring-assignment\r\n            .map(function (prop) { return this$1.props[prop] !== prevProps[prop]; })\r\n            .reduce(function (accum, same) { return accum || same; }, false);\r\n\r\n        // Compare minSize when both are arrays, when one is an array and when neither is an array\r\n        if (Array.isArray(minSize) && Array.isArray(prevMinSize)) {\r\n            var minSizeChanged = false;\r\n\r\n            minSize.forEach(function (minSizeI, i) {\r\n                minSizeChanged = minSizeChanged || minSizeI !== prevMinSize[i];\r\n            });\r\n\r\n            needsRecreate = needsRecreate || minSizeChanged;\r\n        } else if (Array.isArray(minSize) || Array.isArray(prevMinSize)) {\r\n            needsRecreate = true;\r\n        } else {\r\n            needsRecreate = needsRecreate || minSize !== prevMinSize;\r\n        }\r\n\r\n        // Destroy and re-create split if options changed\r\n        if (needsRecreate) {\r\n            options.minSize = minSize;\r\n            options.sizes = sizes || this.split.getSizes();\r\n            this.split.destroy(true, true);\r\n            options.gutter = function (index, direction, pairB) { return pairB.previousSibling; };\r\n            this.split = Split(\r\n                Array.from(this.parent.children).filter(\r\n                    // eslint-disable-next-line no-underscore-dangle\r\n                    function (element) { return !element.__isSplitGutter; }\r\n                ),\r\n                options\r\n            );\r\n        } else if (sizes) {\r\n            // If only the size has changed, set the size. No need to do this if re-created.\r\n            var sizeChanged = false;\r\n\r\n            sizes.forEach(function (sizeI, i) {\r\n                sizeChanged = sizeChanged || sizeI !== prevSizes[i];\r\n            });\r\n\r\n            if (sizeChanged) {\r\n                // eslint-disable-next-line react/destructuring-assignment\r\n                this.split.setSizes(this.props.sizes);\r\n            }\r\n        }\r\n\r\n        // Collapse after re-created or when collapsed changed.\r\n        if (\r\n            Number.isInteger(collapsed) &&\r\n            (collapsed !== prevCollapsed || needsRecreate)\r\n        ) {\r\n            this.split.collapse(collapsed);\r\n        }\r\n    };\r\n\r\n    SplitWrapper.prototype.componentWillUnmount = function componentWillUnmount () {\r\n        this.split.destroy();\r\n        delete this.split;\r\n    };\r\n\r\n    SplitWrapper.prototype.render = function render () {\r\n        var this$1 = this;\r\n\r\n        var ref = this.props;\r\n        ref.sizes;\r\n        ref.minSize;\r\n        ref.maxSize;\r\n        ref.expandToMin;\r\n        ref.gutterSize;\r\n        ref.gutterAlign;\r\n        ref.snapOffset;\r\n        ref.dragInterval;\r\n        ref.direction;\r\n        ref.cursor;\r\n        ref.gutter;\r\n        ref.elementStyle;\r\n        ref.gutterStyle;\r\n        ref.onDrag;\r\n        ref.onDragStart;\r\n        ref.onDragEnd;\r\n        ref.collapsed;\r\n        var children = ref.children;\r\n        var rest$1 = objectWithoutProperties( ref, [\"sizes\", \"minSize\", \"maxSize\", \"expandToMin\", \"gutterSize\", \"gutterAlign\", \"snapOffset\", \"dragInterval\", \"direction\", \"cursor\", \"gutter\", \"elementStyle\", \"gutterStyle\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"collapsed\", \"children\"] );\r\n        var rest = rest$1;\r\n\r\n        return (\r\n            React.createElement( 'div', Object.assign({},\r\n                { ref: function (parent) {\r\n                    this$1.parent = parent;\r\n                } }, rest),\r\n                children\r\n            )\r\n        )\r\n    };\r\n\r\n    return SplitWrapper;\r\n}(React.Component));\r\n\r\nSplitWrapper.propTypes = {\r\n    sizes: PropTypes.arrayOf(PropTypes.number),\r\n    minSize: PropTypes.oneOfType([\r\n        PropTypes.number,\r\n        PropTypes.arrayOf(PropTypes.number) ]),\r\n    maxSize: PropTypes.oneOfType([\r\n        PropTypes.number,\r\n        PropTypes.arrayOf(PropTypes.number) ]),\r\n    expandToMin: PropTypes.bool,\r\n    gutterSize: PropTypes.number,\r\n    gutterAlign: PropTypes.string,\r\n    snapOffset: PropTypes.oneOfType([\r\n        PropTypes.number,\r\n        PropTypes.arrayOf(PropTypes.number) ]),\r\n    dragInterval: PropTypes.number,\r\n    direction: PropTypes.string,\r\n    cursor: PropTypes.string,\r\n    gutter: PropTypes.func,\r\n    elementStyle: PropTypes.func,\r\n    gutterStyle: PropTypes.func,\r\n    onDrag: PropTypes.func,\r\n    onDragStart: PropTypes.func,\r\n    onDragEnd: PropTypes.func,\r\n    collapsed: PropTypes.number,\r\n    children: PropTypes.arrayOf(PropTypes.element),\r\n};\r\n\r\nSplitWrapper.defaultProps = {\r\n    sizes: undefined,\r\n    minSize: undefined,\r\n    maxSize: undefined,\r\n    expandToMin: undefined,\r\n    gutterSize: undefined,\r\n    gutterAlign: undefined,\r\n    snapOffset: undefined,\r\n    dragInterval: undefined,\r\n    direction: undefined,\r\n    cursor: undefined,\r\n    gutter: undefined,\r\n    elementStyle: undefined,\r\n    gutterStyle: undefined,\r\n    onDrag: undefined,\r\n    onDragStart: undefined,\r\n    onDragEnd: undefined,\r\n    collapsed: undefined,\r\n    children: undefined,\r\n};\r\n\r\nexport default SplitWrapper;\r\n", "// The programming goals of Split.js are to deliver readable, understandable and\r\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\r\n// browser compatibility without additional requirements\r\n// and very few assumptions about the user's page layout.\r\nvar global = typeof window !== 'undefined' ? window : null;\r\nvar ssr = global === null;\r\nvar document = !ssr ? global.document : undefined;\r\n\r\n// Save a couple long function names that are used frequently.\r\n// This optimization saves around 400 bytes.\r\nvar addEventListener = 'addEventListener';\r\nvar removeEventListener = 'removeEventListener';\r\nvar getBoundingClientRect = 'getBoundingClientRect';\r\nvar gutterStartDragging = '_a';\r\nvar aGutterSize = '_b';\r\nvar bGutterSize = '_c';\r\nvar HORIZONTAL = 'horizontal';\r\nvar NOOP = function () { return false; };\r\n\r\n// Helper function determines which prefixes of CSS calc we need.\r\n// We only need to do this once on startup, when this anonymous function is called.\r\n//\r\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\r\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\r\nvar calc = ssr\r\n    ? 'calc'\r\n    : ((['', '-webkit-', '-moz-', '-o-']\r\n          .filter(function (prefix) {\r\n              var el = document.createElement('div');\r\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\r\n\r\n              return !!el.style.length\r\n          })\r\n          .shift()) + \"calc\");\r\n\r\n// Helper function checks if its argument is a string-like type\r\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\r\n\r\n// Helper function allows elements and string selectors to be used\r\n// interchangeably. In either case an element is returned. This allows us to\r\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\r\nvar elementOrSelector = function (el) {\r\n    if (isString(el)) {\r\n        var ele = document.querySelector(el);\r\n        if (!ele) {\r\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\r\n        }\r\n        return ele\r\n    }\r\n\r\n    return el\r\n};\r\n\r\n// Helper function gets a property from the properties object, with a default fallback\r\nvar getOption = function (options, propName, def) {\r\n    var value = options[propName];\r\n    if (value !== undefined) {\r\n        return value\r\n    }\r\n    return def\r\n};\r\n\r\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\r\n    if (isFirst) {\r\n        if (gutterAlign === 'end') {\r\n            return 0\r\n        }\r\n        if (gutterAlign === 'center') {\r\n            return gutterSize / 2\r\n        }\r\n    } else if (isLast) {\r\n        if (gutterAlign === 'start') {\r\n            return 0\r\n        }\r\n        if (gutterAlign === 'center') {\r\n            return gutterSize / 2\r\n        }\r\n    }\r\n\r\n    return gutterSize\r\n};\r\n\r\n// Default options\r\nvar defaultGutterFn = function (i, gutterDirection) {\r\n    var gut = document.createElement('div');\r\n    gut.className = \"gutter gutter-\" + gutterDirection;\r\n    return gut\r\n};\r\n\r\nvar defaultElementStyleFn = function (dim, size, gutSize) {\r\n    var style = {};\r\n\r\n    if (!isString(size)) {\r\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\r\n    } else {\r\n        style[dim] = size;\r\n    }\r\n\r\n    return style\r\n};\r\n\r\nvar defaultGutterStyleFn = function (dim, gutSize) {\r\n    var obj;\r\n\r\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\r\n};\r\n\r\n// The main function to initialize a split. Split.js thinks about each pair\r\n// of elements as an independant pair. Dragging the gutter between two elements\r\n// only changes the dimensions of elements in that pair. This is key to understanding\r\n// how the following functions operate, since each function is bound to a pair.\r\n//\r\n// A pair object is shaped like this:\r\n//\r\n// {\r\n//     a: DOM element,\r\n//     b: DOM element,\r\n//     aMin: Number,\r\n//     bMin: Number,\r\n//     dragging: Boolean,\r\n//     parent: DOM element,\r\n//     direction: 'horizontal' | 'vertical'\r\n// }\r\n//\r\n// The basic sequence:\r\n//\r\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\r\n// 2. Initialize a bunch of strings based on the direction we're splitting.\r\n//    A lot of the behavior in the rest of the library is paramatized down to\r\n//    rely on CSS strings and classes.\r\n// 3. Define the dragging helper functions, and a few helpers to go with them.\r\n// 4. Loop through the elements while pairing them off. Every pair gets an\r\n//    `pair` object and a gutter.\r\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\r\nvar Split = function (idsOption, options) {\r\n    if ( options === void 0 ) options = {};\r\n\r\n    if (ssr) { return {} }\r\n\r\n    var ids = idsOption;\r\n    var dimension;\r\n    var clientAxis;\r\n    var position;\r\n    var positionEnd;\r\n    var clientSize;\r\n    var elements;\r\n\r\n    // Allow HTMLCollection to be used as an argument when supported\r\n    if (Array.from) {\r\n        ids = Array.from(ids);\r\n    }\r\n\r\n    // All DOM elements in the split should have a common parent. We can grab\r\n    // the first elements parent and hope users read the docs because the\r\n    // behavior will be whacky otherwise.\r\n    var firstElement = elementOrSelector(ids[0]);\r\n    var parent = firstElement.parentNode;\r\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\r\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\r\n\r\n    // Set default options.sizes to equal percentages of the parent element.\r\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\r\n\r\n    // Standardize minSize and maxSize to an array if it isn't already.\r\n    // This allows minSize and maxSize to be passed as a number.\r\n    var minSize = getOption(options, 'minSize', 100);\r\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\r\n    var maxSize = getOption(options, 'maxSize', Infinity);\r\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\r\n\r\n    // Get other options\r\n    var expandToMin = getOption(options, 'expandToMin', false);\r\n    var gutterSize = getOption(options, 'gutterSize', 10);\r\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\r\n    var snapOffset = getOption(options, 'snapOffset', 30);\r\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\r\n    var dragInterval = getOption(options, 'dragInterval', 1);\r\n    var direction = getOption(options, 'direction', HORIZONTAL);\r\n    var cursor = getOption(\r\n        options,\r\n        'cursor',\r\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\r\n    );\r\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\r\n    var elementStyle = getOption(\r\n        options,\r\n        'elementStyle',\r\n        defaultElementStyleFn\r\n    );\r\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\r\n\r\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\r\n    // A lot of the behavior in the rest of the library is paramatized down to\r\n    // rely on CSS strings and classes.\r\n    if (direction === HORIZONTAL) {\r\n        dimension = 'width';\r\n        clientAxis = 'clientX';\r\n        position = 'left';\r\n        positionEnd = 'right';\r\n        clientSize = 'clientWidth';\r\n    } else if (direction === 'vertical') {\r\n        dimension = 'height';\r\n        clientAxis = 'clientY';\r\n        position = 'top';\r\n        positionEnd = 'bottom';\r\n        clientSize = 'clientHeight';\r\n    }\r\n\r\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\r\n    // Each helper is bound to a pair object that contains its metadata. This\r\n    // also makes it easy to store references to listeners that that will be\r\n    // added and removed.\r\n    //\r\n    // Even though there are no other functions contained in them, aliasing\r\n    // this to self saves 50 bytes or so since it's used so frequently.\r\n    //\r\n    // The pair object saves metadata like dragging state, position and\r\n    // event listener references.\r\n\r\n    function setElementSize(el, size, gutSize, i) {\r\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\r\n        // by string, like '300px'. This is less than ideal, because it breaks\r\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\r\n        // make sure you calculate the gutter size by hand.\r\n        var style = elementStyle(dimension, size, gutSize, i);\r\n\r\n        Object.keys(style).forEach(function (prop) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            el.style[prop] = style[prop];\r\n        });\r\n    }\r\n\r\n    function setGutterSize(gutterElement, gutSize, i) {\r\n        var style = gutterStyle(dimension, gutSize, i);\r\n\r\n        Object.keys(style).forEach(function (prop) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            gutterElement.style[prop] = style[prop];\r\n        });\r\n    }\r\n\r\n    function getSizes() {\r\n        return elements.map(function (element) { return element.size; })\r\n    }\r\n\r\n    // Supports touch events, but not multitouch, so only the first\r\n    // finger `touches[0]` is counted.\r\n    function getMousePosition(e) {\r\n        if ('touches' in e) { return e.touches[0][clientAxis] }\r\n        return e[clientAxis]\r\n    }\r\n\r\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\r\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\r\n    // which allows the viewport to be resized without additional logic.\r\n    // Element a's size is the same as offset. b's size is total size - a size.\r\n    // Both sizes are calculated from the initial parent percentage,\r\n    // then the gutter size is subtracted.\r\n    function adjust(offset) {\r\n        var a = elements[this.a];\r\n        var b = elements[this.b];\r\n        var percentage = a.size + b.size;\r\n\r\n        a.size = (offset / this.size) * percentage;\r\n        b.size = percentage - (offset / this.size) * percentage;\r\n\r\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\r\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\r\n    }\r\n\r\n    // drag, where all the magic happens. The logic is really quite simple:\r\n    //\r\n    // 1. Ignore if the pair is not dragging.\r\n    // 2. Get the offset of the event.\r\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\r\n    // 4. Actually adjust each element in the pair to offset.\r\n    //\r\n    // ---------------------------------------------------------------------\r\n    // |    | <- a.minSize               ||              b.minSize -> |    |\r\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\r\n    // |    |  |                         ||                        |  |    |\r\n    // |    |  |                         ||                        |  |    |\r\n    // ---------------------------------------------------------------------\r\n    // | <- this.start                                        this.size -> |\r\n    function drag(e) {\r\n        var offset;\r\n        var a = elements[this.a];\r\n        var b = elements[this.b];\r\n\r\n        if (!this.dragging) { return }\r\n\r\n        // Get the offset of the event from the first side of the\r\n        // pair `this.start`. Then offset by the initial position of the\r\n        // mouse compared to the gutter size.\r\n        offset =\r\n            getMousePosition(e) -\r\n            this.start +\r\n            (this[aGutterSize] - this.dragOffset);\r\n\r\n        if (dragInterval > 1) {\r\n            offset = Math.round(offset / dragInterval) * dragInterval;\r\n        }\r\n\r\n        // If within snapOffset of min or max, set offset to min or max.\r\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\r\n        // Include the appropriate gutter sizes to prevent overflows.\r\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\r\n            offset = a.minSize + this[aGutterSize];\r\n        } else if (\r\n            offset >=\r\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\r\n        ) {\r\n            offset = this.size - (b.minSize + this[bGutterSize]);\r\n        }\r\n\r\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\r\n            offset = a.maxSize + this[aGutterSize];\r\n        } else if (\r\n            offset <=\r\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\r\n        ) {\r\n            offset = this.size - (b.maxSize + this[bGutterSize]);\r\n        }\r\n\r\n        // Actually adjust the size.\r\n        adjust.call(this, offset);\r\n\r\n        // Call the drag callback continously. Don't do anything too intensive\r\n        // in this callback.\r\n        getOption(options, 'onDrag', NOOP)(getSizes());\r\n    }\r\n\r\n    // Cache some important sizes when drag starts, so we don't have to do that\r\n    // continously:\r\n    //\r\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\r\n    // `start`: The leading side of the first element.\r\n    //\r\n    // ------------------------------------------------\r\n    // |      aGutterSize -> |||                      |\r\n    // |                     |||                      |\r\n    // |                     |||                      |\r\n    // |                     ||| <- bGutterSize       |\r\n    // ------------------------------------------------\r\n    // | <- start                             size -> |\r\n    function calculateSizes() {\r\n        // Figure out the parent size minus padding.\r\n        var a = elements[this.a].element;\r\n        var b = elements[this.b].element;\r\n\r\n        var aBounds = a[getBoundingClientRect]();\r\n        var bBounds = b[getBoundingClientRect]();\r\n\r\n        this.size =\r\n            aBounds[dimension] +\r\n            bBounds[dimension] +\r\n            this[aGutterSize] +\r\n            this[bGutterSize];\r\n        this.start = aBounds[position];\r\n        this.end = aBounds[positionEnd];\r\n    }\r\n\r\n    function innerSize(element) {\r\n        // Return nothing if getComputedStyle is not supported (< IE9)\r\n        // Or if parent element has no layout yet\r\n        if (!getComputedStyle) { return null }\r\n\r\n        var computedStyle = getComputedStyle(element);\r\n\r\n        if (!computedStyle) { return null }\r\n\r\n        var size = element[clientSize];\r\n\r\n        if (size === 0) { return null }\r\n\r\n        if (direction === HORIZONTAL) {\r\n            size -=\r\n                parseFloat(computedStyle.paddingLeft) +\r\n                parseFloat(computedStyle.paddingRight);\r\n        } else {\r\n            size -=\r\n                parseFloat(computedStyle.paddingTop) +\r\n                parseFloat(computedStyle.paddingBottom);\r\n        }\r\n\r\n        return size\r\n    }\r\n\r\n    // When specifying percentage sizes that are less than the computed\r\n    // size of the element minus the gutter, the lesser percentages must be increased\r\n    // (and decreased from the other elements) to make space for the pixels\r\n    // subtracted by the gutters.\r\n    function trimToMin(sizesToTrim) {\r\n        // Try to get inner size of parent element.\r\n        // If it's no supported, return original sizes.\r\n        var parentSize = innerSize(parent);\r\n        if (parentSize === null) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\r\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\r\n        var excessPixels = 0;\r\n        var toSpare = [];\r\n\r\n        var pixelSizes = sizesToTrim.map(function (size, i) {\r\n            // Convert requested percentages to pixel sizes\r\n            var pixelSize = (parentSize * size) / 100;\r\n            var elementGutterSize = getGutterSize(\r\n                gutterSize,\r\n                i === 0,\r\n                i === sizesToTrim.length - 1,\r\n                gutterAlign\r\n            );\r\n            var elementMinSize = minSizes[i] + elementGutterSize;\r\n\r\n            // If element is too smal, increase excess pixels by the difference\r\n            // and mark that it has no pixels to spare\r\n            if (pixelSize < elementMinSize) {\r\n                excessPixels += elementMinSize - pixelSize;\r\n                toSpare.push(0);\r\n                return elementMinSize\r\n            }\r\n\r\n            // Otherwise, mark the pixels it has to spare and return it's original size\r\n            toSpare.push(pixelSize - elementMinSize);\r\n            return pixelSize\r\n        });\r\n\r\n        // If nothing was adjusted, return the original sizes\r\n        if (excessPixels === 0) {\r\n            return sizesToTrim\r\n        }\r\n\r\n        return pixelSizes.map(function (pixelSize, i) {\r\n            var newPixelSize = pixelSize;\r\n\r\n            // While there's still pixels to take, and there's enough pixels to spare,\r\n            // take as many as possible up to the total excess pixels\r\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\r\n                var takenPixels = Math.min(\r\n                    excessPixels,\r\n                    toSpare[i] - excessPixels\r\n                );\r\n\r\n                // Subtract the amount taken for the next iteration\r\n                excessPixels -= takenPixels;\r\n                newPixelSize = pixelSize - takenPixels;\r\n            }\r\n\r\n            // Return the pixel size adjusted as a percentage\r\n            return (newPixelSize / parentSize) * 100\r\n        })\r\n    }\r\n\r\n    // stopDragging is very similar to startDragging in reverse.\r\n    function stopDragging() {\r\n        var self = this;\r\n        var a = elements[self.a].element;\r\n        var b = elements[self.b].element;\r\n\r\n        if (self.dragging) {\r\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\r\n        }\r\n\r\n        self.dragging = false;\r\n\r\n        // Remove the stored event listeners. This is why we store them.\r\n        global[removeEventListener]('mouseup', self.stop);\r\n        global[removeEventListener]('touchend', self.stop);\r\n        global[removeEventListener]('touchcancel', self.stop);\r\n        global[removeEventListener]('mousemove', self.move);\r\n        global[removeEventListener]('touchmove', self.move);\r\n\r\n        // Clear bound function references\r\n        self.stop = null;\r\n        self.move = null;\r\n\r\n        a[removeEventListener]('selectstart', NOOP);\r\n        a[removeEventListener]('dragstart', NOOP);\r\n        b[removeEventListener]('selectstart', NOOP);\r\n        b[removeEventListener]('dragstart', NOOP);\r\n\r\n        a.style.userSelect = '';\r\n        a.style.webkitUserSelect = '';\r\n        a.style.MozUserSelect = '';\r\n        a.style.pointerEvents = '';\r\n\r\n        b.style.userSelect = '';\r\n        b.style.webkitUserSelect = '';\r\n        b.style.MozUserSelect = '';\r\n        b.style.pointerEvents = '';\r\n\r\n        self.gutter.style.cursor = '';\r\n        self.parent.style.cursor = '';\r\n        document.body.style.cursor = '';\r\n    }\r\n\r\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\r\n    // It also adds event listeners for mouse/touch events,\r\n    // and prevents selection while dragging so avoid the selecting text.\r\n    function startDragging(e) {\r\n        // Right-clicking can't start dragging.\r\n        if ('button' in e && e.button !== 0) {\r\n            return\r\n        }\r\n\r\n        // Alias frequently used variables to save space. 200 bytes.\r\n        var self = this;\r\n        var a = elements[self.a].element;\r\n        var b = elements[self.b].element;\r\n\r\n        // Call the onDragStart callback.\r\n        if (!self.dragging) {\r\n            getOption(options, 'onDragStart', NOOP)(getSizes());\r\n        }\r\n\r\n        // Don't actually drag the element. We emulate that in the drag function.\r\n        e.preventDefault();\r\n\r\n        // Set the dragging property of the pair object.\r\n        self.dragging = true;\r\n\r\n        // Create two event listeners bound to the same pair object and store\r\n        // them in the pair object.\r\n        self.move = drag.bind(self);\r\n        self.stop = stopDragging.bind(self);\r\n\r\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\r\n        global[addEventListener]('mouseup', self.stop);\r\n        global[addEventListener]('touchend', self.stop);\r\n        global[addEventListener]('touchcancel', self.stop);\r\n        global[addEventListener]('mousemove', self.move);\r\n        global[addEventListener]('touchmove', self.move);\r\n\r\n        // Disable selection. Disable!\r\n        a[addEventListener]('selectstart', NOOP);\r\n        a[addEventListener]('dragstart', NOOP);\r\n        b[addEventListener]('selectstart', NOOP);\r\n        b[addEventListener]('dragstart', NOOP);\r\n\r\n        a.style.userSelect = 'none';\r\n        a.style.webkitUserSelect = 'none';\r\n        a.style.MozUserSelect = 'none';\r\n        a.style.pointerEvents = 'none';\r\n\r\n        b.style.userSelect = 'none';\r\n        b.style.webkitUserSelect = 'none';\r\n        b.style.MozUserSelect = 'none';\r\n        b.style.pointerEvents = 'none';\r\n\r\n        // Set the cursor at multiple levels\r\n        self.gutter.style.cursor = cursor;\r\n        self.parent.style.cursor = cursor;\r\n        document.body.style.cursor = cursor;\r\n\r\n        // Cache the initial sizes of the pair.\r\n        calculateSizes.call(self);\r\n\r\n        // Determine the position of the mouse compared to the gutter\r\n        self.dragOffset = getMousePosition(e) - self.end;\r\n    }\r\n\r\n    // adjust sizes to ensure percentage is within min size and gutter.\r\n    sizes = trimToMin(sizes);\r\n\r\n    // 5. Create pair and element objects. Each pair has an index reference to\r\n    // elements `a` and `b` of the pair (first and second elements).\r\n    // Loop through the elements while pairing them off. Every pair gets a\r\n    // `pair` object and a gutter.\r\n    //\r\n    // Basic logic:\r\n    //\r\n    // - Starting with the second element `i > 0`, create `pair` objects with\r\n    //   `a = i - 1` and `b = i`\r\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\r\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\r\n    // - Create gutter elements and add event listeners.\r\n    // - Set the size of the elements, minus the gutter sizes.\r\n    //\r\n    // -----------------------------------------------------------------------\r\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\r\n    // |             |                     |                  |              |\r\n    // |           pair 0                pair 1             pair 2           |\r\n    // |             |                     |                  |              |\r\n    // -----------------------------------------------------------------------\r\n    var pairs = [];\r\n    elements = ids.map(function (id, i) {\r\n        // Create the element object.\r\n        var element = {\r\n            element: elementOrSelector(id),\r\n            size: sizes[i],\r\n            minSize: minSizes[i],\r\n            maxSize: maxSizes[i],\r\n            snapOffset: snapOffsets[i],\r\n            i: i,\r\n        };\r\n\r\n        var pair;\r\n\r\n        if (i > 0) {\r\n            // Create the pair object with its metadata.\r\n            pair = {\r\n                a: i - 1,\r\n                b: i,\r\n                dragging: false,\r\n                direction: direction,\r\n                parent: parent,\r\n            };\r\n\r\n            pair[aGutterSize] = getGutterSize(\r\n                gutterSize,\r\n                i - 1 === 0,\r\n                false,\r\n                gutterAlign\r\n            );\r\n            pair[bGutterSize] = getGutterSize(\r\n                gutterSize,\r\n                false,\r\n                i === ids.length - 1,\r\n                gutterAlign\r\n            );\r\n\r\n            // if the parent has a reverse flex-direction, switch the pair elements.\r\n            if (\r\n                parentFlexDirection === 'row-reverse' ||\r\n                parentFlexDirection === 'column-reverse'\r\n            ) {\r\n                var temp = pair.a;\r\n                pair.a = pair.b;\r\n                pair.b = temp;\r\n            }\r\n        }\r\n\r\n        // Determine the size of the current element. IE8 is supported by\r\n        // staticly assigning sizes without draggable gutters. Assigns a string\r\n        // to `size`.\r\n        //\r\n        // Create gutter elements for each pair.\r\n        if (i > 0) {\r\n            var gutterElement = gutter(i, direction, element.element);\r\n            setGutterSize(gutterElement, gutterSize, i);\r\n\r\n            // Save bound event listener for removal later\r\n            pair[gutterStartDragging] = startDragging.bind(pair);\r\n\r\n            // Attach bound event listener\r\n            gutterElement[addEventListener](\r\n                'mousedown',\r\n                pair[gutterStartDragging]\r\n            );\r\n            gutterElement[addEventListener](\r\n                'touchstart',\r\n                pair[gutterStartDragging]\r\n            );\r\n\r\n            parent.insertBefore(gutterElement, element.element);\r\n\r\n            pair.gutter = gutterElement;\r\n        }\r\n\r\n        setElementSize(\r\n            element.element,\r\n            element.size,\r\n            getGutterSize(\r\n                gutterSize,\r\n                i === 0,\r\n                i === ids.length - 1,\r\n                gutterAlign\r\n            ),\r\n            i\r\n        );\r\n\r\n        // After the first iteration, and we have a pair object, append it to the\r\n        // list of pairs.\r\n        if (i > 0) {\r\n            pairs.push(pair);\r\n        }\r\n\r\n        return element\r\n    });\r\n\r\n    function adjustToMin(element) {\r\n        var isLast = element.i === pairs.length;\r\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\r\n\r\n        calculateSizes.call(pair);\r\n\r\n        var size = isLast\r\n            ? pair.size - element.minSize - pair[bGutterSize]\r\n            : element.minSize + pair[aGutterSize];\r\n\r\n        adjust.call(pair, size);\r\n    }\r\n\r\n    elements.forEach(function (element) {\r\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\r\n\r\n        if (computedSize < element.minSize) {\r\n            if (expandToMin) {\r\n                adjustToMin(element);\r\n            } else {\r\n                // eslint-disable-next-line no-param-reassign\r\n                element.minSize = computedSize;\r\n            }\r\n        }\r\n    });\r\n\r\n    function setSizes(newSizes) {\r\n        var trimmed = trimToMin(newSizes);\r\n        trimmed.forEach(function (newSize, i) {\r\n            if (i > 0) {\r\n                var pair = pairs[i - 1];\r\n\r\n                var a = elements[pair.a];\r\n                var b = elements[pair.b];\r\n\r\n                a.size = trimmed[i - 1];\r\n                b.size = newSize;\r\n\r\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\r\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\r\n            }\r\n        });\r\n    }\r\n\r\n    function destroy(preserveStyles, preserveGutter) {\r\n        pairs.forEach(function (pair) {\r\n            if (preserveGutter !== true) {\r\n                pair.parent.removeChild(pair.gutter);\r\n            } else {\r\n                pair.gutter[removeEventListener](\r\n                    'mousedown',\r\n                    pair[gutterStartDragging]\r\n                );\r\n                pair.gutter[removeEventListener](\r\n                    'touchstart',\r\n                    pair[gutterStartDragging]\r\n                );\r\n            }\r\n\r\n            if (preserveStyles !== true) {\r\n                var style = elementStyle(\r\n                    dimension,\r\n                    pair.a.size,\r\n                    pair[aGutterSize]\r\n                );\r\n\r\n                Object.keys(style).forEach(function (prop) {\r\n                    elements[pair.a].element.style[prop] = '';\r\n                    elements[pair.b].element.style[prop] = '';\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    return {\r\n        setSizes: setSizes,\r\n        getSizes: getSizes,\r\n        collapse: function collapse(i) {\r\n            adjustToMin(elements[i]);\r\n        },\r\n        destroy: destroy,\r\n        parent: parent,\r\n        pairs: pairs,\r\n    }\r\n};\r\n\r\nexport default Split;\r\n"],
  "mappings": "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",
  "names": ["document", "SplitWrapper", "React", "PropTypes"]
}
